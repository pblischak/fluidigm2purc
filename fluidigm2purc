#!/usr/bin/env python
# -*- coding: utf-8 -*-

# fluidigm2purc
# Written by PD Blischak

from __future__ import print_function
import subprocess as sps
import sys
import argparse
import gzip
import itertools

#### header and version info. ##################################################

__version__ = "This is fluidigm2purc v0.1.0-alpha (April 2017)."

__header__ = """**********************************************
fluidigm2purc (v0.1.0-alpha)

Processing of paired-end FASTQ data from the
Fluidigm platform for input to PURC.
**********************************************
"""

#### functions to run executables, process FASTQs. #############################

def run_sickle(prefix, outname, quality, min_length):
    """
    Runs the program Sickle to trim and filters reads.

    Sickle:
    Joshi NA, Fass JN. (2011). Sickle: A sliding-window, adaptive, quality-based
    trimming tool for FastQ files (Version 1.33) [Software].
    Available at https://github.com/najoshi/sickle.
    """
    print("\n**** 1. Trimming and filtering paired-end reads with Sickle ****\n\n")

    # test the executable first
    print("  Checking Sickle executable...    ", end='')
    test_proc = sps.Popen(['sickle'], stdout=sps.PIPE, stderr=sps.PIPE, shell=True)
    (out, err) = test_proc.communicate()
    if not str(out).startswith('\nUsage'):
        sys.exit("\n\n** ERROR: could not execute Sickle **\n\n")
    else:
        print("Good\n")

    sickle_cmd = [
        "sickle", "pe",
        "-f", prefix+"_R1.fastq.gz",
        "-r", prefix+"_R2.fastq.gz",
        "-t", "sanger",
        "-o", outname+"-sickled_R1.fastq.gz",
        "-p", outname+"-sickled_R2.fastq.gz",
        "-s", outname+"-sickled_singles.fastq.gz",
        "-q", str(quality),
        "-l", str(min_length),
        "-g"
    ]

    proc = sps.call(sickle_cmd)#, stdin=sps.PIPE, stdout=sps.PIPE, close_fds=True)

def run_flash2(outname, threads):
    """
    Run th program FLASH2 to merge paired-end reads that are filtered and trimmed
    by Sickle. The command line arguments are the same that are used by the
    dbcAplicons script 'reduce_amplicons.R'.

    FLASH2:
    Tanja Magoč and Steven L. Salzberg. (2011). FLASH: fast length adjustment of
    short reads to improve genome assemblies. Bioinformatics 27:
    http://bioinformatics.oxfordjournals.org/content/27/21/2957.full
    """
    print("\n**** 2. Merging reads using FLASH2 ****\n")

    # test the executable first
    print("  Checking FLASH2 executable...    ", end='')
    test_proc = sps.Popen(['flash2'], stdout=sps.PIPE, stderr=sps.PIPE, shell=True)
    (out, err) = test_proc.communicate()
    if not str(err).startswith('Usage'):
        sys.exit("\n\n** ERROR: Could not execute FLASH2 **\n\n")
    else:
        print("Good\n")

    print("  Note: FLASH2 always produces a warning about adapter trimming.")
    print("        It can be safely ignored.\n\n")

    flash2_cmd = [
        "flash2",
        "--max-overlap=600",
        "--allow-outies",
        "-t", str(threads),
        "-x", "0.25",
        "-z", "--quiet",
        "-o", outname+"-flashed",
        outname+"-sickled_R1.fastq.gz",
        outname+"-sickled_R2.fastq.gz"
    ]

    proc = sps.call(flash2_cmd)

def _run_pear(prefix, outname, quality, threads):
    """
    **** EXPERIMENTAL ****

    Run the program PEAR to merge paired-end reads. Performs read trimming
    so we don't need to do this ahead of time, but can do it using Sickle
    if you want.

    PEAR:
    J. Zhang, K. Kobert, T. Flouri, A. Stamatakis. PEAR: A fast and accurate
    Illumina Paired-End reAd mergeR. Bioinformatics 30(5): 614-620, 2014.
    """
    print("\n**** Merging reads using PEAR ****\n\n")

    pear_cmd = [
        "pear",
        "-f", prefix + "_R1.fastq.gz",
        "-r", prefix + "_R2.fastq.gz",
        "-o", outname,
        "-q", str(quality),
        "-j", str(threads),
        "-k"
    ]


    proc = sps.call(pear_cmd)


# Define global variables for taxa and loci.
# Used for writing logfile.
taxa = []
loci = []
def PURCify_fastq(outname, gz):
    """
    Function for reading in FASTQ files and converting to PURC-style FASTA.
    Uses taxon and locus names in the FASTQ sequence headers. Prints unmerged
    reads from FLASH2 with 8 n's in between the two paired reads.
    """
    print("\n**** 3. PURCifying FASTQ files ****\n\n")
    outfile = open(outname+".fasta", 'w')
    #outfile = gzip.open(outname+".fasta", 'wb')
    line_counter = 1
    for line in gzip.open(outname+"-flashed.extendedFrags.fastq.gz"):
        if line_counter == 1:
            info = line.strip().split(" ")[1].split(":")
            print(">", info[-2], "|", info[-1], file=outfile, sep='')
            if info[-1] not in loci:
                loci.append(info[-1])
            if info[-2] not in taxa:
                taxa.append(info[-2])
            #outfile.write(">%s|%s\n" % (info[-2], info[-1]))
            line_counter = 2
        elif line_counter == 2:
            print(line.strip(), file=outfile, sep='')
            #outfile.write("%s\n" % (line.strip()))
            line_counter = 3
        elif line_counter == 3:
            line_counter = 4
        elif line_counter == 4:
            line_counter = 1
        else:
            raise_error("Something done messed up.", line_counter)

    # Combine unmerged reads with 8 N's in between them.
    unmerged1 = gzip.open(outname+"-flashed.notCombined_1.fastq.gz")
    unmerged2 = gzip.open(outname+"-flashed.notCombined_2.fastq.gz")
    line_counter = 1
    for line1, line2 in itertools.izip(unmerged1,unmerged2):
        if line_counter == 1:
            info1 = line1.strip().split(" ")[1].split(":")
            info2 = line2.strip().split(" ")[1].split(":")
            assert info1[-1] == info2[-1]
            assert info1[-2] == info2[-2]
            print(">", info1[-2], "|", info1[-1], file=outfile, sep='')
            if info[-1] not in loci:
                loci.append(info[-1])
            if info[-2] not in taxa:
                taxa.append(info[-2])
            #outfile.write(">%s|%s\n" % (info1[-2], info1[-1]))
            line_counter = 2
        elif line_counter == 2:
            print(line1.strip(), "nnnnnnnn", line2.strip(), file=outfile, sep='')
            #outfile.write("%snnnnnnnn%s\n" % (line1.strip(), line2.strip()))
            line_counter = 3
        elif line_counter == 3:
            line_counter = 4
        elif line_counter == 4:
            line_counter = 1
        else:
            raise_error("Something done messed up.", line_counter)

    if gz:
        print("**** Compressing output FASTA file '"+outname+".fasta' using gzip. ****\n", sep='')
        gzip_cmd = [
            "gzip",
            outname+".fasta"
        ]
        proc = sps.call(gzip_cmd)

#### some utility functions. ###################################################

def raise_error(error_message, bad_arg):
    """
    Prints error message and exits program.
    """
    print("\n** ERROR: ", error_message, " **\n", sep='')
    print("  => Option provided: ", bad_arg, "\n", sep='')
    sys.exit(-1)

def write_log(outname, args, program):
    """
    Writes summary of fluidigm2purc run.
    Prints taxa and loci retained after filtering.
    """
    logfile = open(outname+".log", 'w')
    print(__header__, file=logfile)
    print("Command line call:\n  ", end='', file=logfile)
    for a in args:
        print(a, " ", sep='', end='', file=logfile)

    if program == "all" or program == "PURCify":
        print("\n\nTaxa retained:\n", end='', file=logfile)
        for t in taxa:
            print("  ", t, file=logfile)
        print("\nLoci retained:\n", end='', file=logfile)
        for l in loci:
            print("  ", l, file=logfile)

#### main functions. ###########################################################

def main():
    """
    Main function for fluidigm2purc.

    It parses command line arguments and runs two or three steps:
        1. Optional paired end trimming and filtering of reads using Sickle.
        2. Read merging (and optional trimming) using PEAR.
        3. Converting merged FASTQ files to fasta with modified sequence headers.
    """
    parser = argparse.ArgumentParser(description="Options for fluidigm2purc",
                                     add_help=True)
    parser.add_argument('-v', '--version', action="version",
                        version=__version__)

    required = parser.add_argument_group("required arguments")
    required.add_argument('-f', '--fastq_prefix', action="store", required=True,
                          metavar='\b', help="prefix for paired-end FASTQ files")

    additional = parser.add_argument_group("additional arguments")
    additional.add_argument('-p', '--program', action="store", type=str, default="all",
                            metavar='\b', help="programs to run [all]")
    additional.add_argument('-o', '--outname', action="store", type=str, default="output",
                            metavar='\b', help="base name for output fasta file [output]")
    additional.add_argument('-j', '--nthreads', action="store", type=int, default=1,
                            metavar='\b', help="number of threads to use for executables [1]")
    additional.add_argument('-q', '--quality', action="store", type=int, default=20,
                            metavar='\b', help="PHRED quality score cutoff [20]")
    additional.add_argument('-l', '--length', action="store", type=int, default=100,
                            metavar='\b', help="minimum length for Sickle trimming [100]")
    additional.add_argument('-g', '--gzip', action="store_true", default=False,
                            help="compress output fasta [False]")

    args    = parser.parse_args()
    prefix  = args.fastq_prefix
    outname = args.outname
    threads = args.nthreads
    quality = args.quality
    length  = args.length
    program = args.program
    gzip    = args.gzip

    print("\n", __header__, sep='')

    if program == "all":
        run_sickle(prefix, outname, quality, length)
        run_flash2(outname, threads)
        PURCify_fastq(outname, gzip)
    elif program == "sickle":
        run_sickle(prefix, outname, quality, length)
    elif program == "flash2":
        run_flash2(outname, threads)
    elif program == "PURCify":
        PURCify_fastq(outname, gzip)
    else:
        raise_error("Invalid program spcified. Choose one of the following: 'all', 'sickle', 'flash2', 'PURCify'.", program)

    write_log(outname, sys.argv, program)
    print("**** DONE: Run info written to '" + outname + ".log' ****\n", sep='')

if __name__ == "__main__":
    """
    Run the main function when called from command line.
    """
    main()
